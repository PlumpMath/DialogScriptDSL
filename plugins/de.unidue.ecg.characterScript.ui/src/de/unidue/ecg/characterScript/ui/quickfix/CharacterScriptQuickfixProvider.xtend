/*
* generated by Xtext
*/
package de.unidue.ecg.characterScript.ui.quickfix

import com.google.inject.Inject
import de.unidue.ecg.characterScript.characterScript.Age
import de.unidue.ecg.characterScript.characterScript.AttributeType
import de.unidue.ecg.characterScript.characterScript.CharaSex
import de.unidue.ecg.characterScript.characterScript.CharaType
import de.unidue.ecg.characterScript.characterScript.Character
import de.unidue.ecg.characterScript.characterScript.CharacterScriptFactory
import de.unidue.ecg.characterScript.characterScript.CharacterScriptPackage
import de.unidue.ecg.characterScript.characterScript.Characters
import de.unidue.ecg.characterScript.characterScript.CustomProperty
import de.unidue.ecg.characterScript.characterScript.Description
import de.unidue.ecg.characterScript.characterScript.FullName
import de.unidue.ecg.characterScript.characterScript.Sex
import de.unidue.ecg.characterScript.characterScript.Type
import de.unidue.ecg.characterScript.validation.CharacterScriptValidator
import de.unidue.ecg.common.linking.CustomLinkingDiagnosticMessageProvider
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.Keyword
import org.eclipse.xtext.diagnostics.Diagnostic
import org.eclipse.xtext.nodemodel.impl.HiddenLeafNode
import org.eclipse.xtext.nodemodel.impl.LeafNode
import org.eclipse.xtext.nodemodel.util.NodeModelUtils
import org.eclipse.xtext.ui.editor.quickfix.DefaultQuickfixProvider
import org.eclipse.xtext.ui.editor.quickfix.Fix
import org.eclipse.xtext.ui.editor.quickfix.IssueResolutionAcceptor
import org.eclipse.xtext.validation.Issue

/**
 * Custom quickfixes.
 *
 * see http://www.eclipse.org/Xtext/documentation.html#quickfixes
 */
class CharacterScriptQuickfixProvider extends DefaultQuickfixProvider {
	@Inject
	CustomLinkingDiagnosticMessageProvider customLinkingDiagnosticMessageProvider

	@Fix(CharacterScriptValidator.UNRESOLVED_TEMPLATE)
	def createImport(Issue issue, IssueResolutionAcceptor acceptor) {
		val linkText = issue.data.get(0)
		issue.addImportTemplateFix(acceptor, linkText)
		issue.addLocalTemplateFix(acceptor, linkText)
	}

	@Fix(CharacterScriptValidator.MISSING_REQUIRED_DEFAULT)
	def addRequiredDefault(Issue issue, IssueResolutionAcceptor acceptor) {
		val propName = issue.data.get(0)
		
		acceptor.accept(issue, 'Add missing attribute \'' + propName + '\'',
			'Add missing attribute \'' + propName + '\'', null) [ element, context |
				if(element instanceof Character) {
					val character = element as Character
					val template = character.template
					
					if(template != null) {
						switch(propName) {
							case 'full name': {
								val property = CharacterScriptFactory.eINSTANCE.createFullName
								property.value = 'XYZ'
								property.comment = '[FIX ME!]'
								character.properties.add(property)
							}
							case 'sex': {
								val property = CharacterScriptFactory.eINSTANCE.createSex
								property.value = CharaSex.FEMALE
								property.comment = '[FIX ME!]'
								character.properties.add(property)
							}
							case 'type': {
								val property = CharacterScriptFactory.eINSTANCE.createType
								property.value = CharaType.PC
								property.comment = '[FIX ME!]'
								character.properties.add(property)
							}
							case 'age': {
								val property = CharacterScriptFactory.eINSTANCE.createAge
								property.value = 0
								property.comment = '[FIX ME!]'
								character.properties.add(property)
							}
							case 'description': {
								val property = CharacterScriptFactory.eINSTANCE.createDescription
								property.value = 'XYZ'
								property.comment = '[FIX ME!]'
								character.properties.add(property)
							}
						}
					}
				}	
			]
	}

	@Fix(CharacterScriptValidator.MISSING_REQUIRED_CUSTOM)
	def addRequiredCustom(Issue issue, IssueResolutionAcceptor acceptor) {
		val propName = issue.data.get(0)
		val propValue = issue.data.get(1)

		acceptor.accept(issue, 'Add missing attribute \'' + propName + '\'',
			'Add missing attribute \'' + propName + '\'', null) [ element, context |
			if (element instanceof Character) {
				val character = element as Character
				val template = character.template
				if (template != null) {

					val property = CharacterScriptFactory.eINSTANCE.createCustomProperty
					val ca = template.customs.findFirst[it.caName.name.equals(propName)]
					property.setCustomAttributeRef(ca.caName)
					if (!ca.enumValues.empty) {
						property.setEnumValue(ca.enumValues?.get(0))
					} else {
						switch (ca.type.getName()) {
							case "NUMBER": property.setIntValue(Integer.parseInt(propValue))
							case "TEXT": property.setStringValue(propValue)
						}

					}

					character.properties.add(property)
				}

			}
		]
	}

	def addImportTemplateFix(Issue issue, IssueResolutionAcceptor acceptor, String linkText) {
		if (linkText != null) {

			acceptor.accept(issue, 'Add import for \'' + linkText + '\'', 'Add import for \'' + linkText + '\'', null) [ element, context |
				if (element instanceof Character) {

					val root = EcoreUtil2.getContainerOfType(element, Characters)

					val ^import = CharacterScriptFactory.eINSTANCE.createImport
					^import.setImportedNamespace(linkText)
					root.imports.add(^import)
				}
			]

		}
	}

	@Fix(Diagnostic.LINKING_DIAGNOSTIC)
	def createTemplate(Issue issue, IssueResolutionAcceptor acceptor) {
		val linkText = customLinkingDiagnosticMessageProvider.getLinkText(issue,
			CharacterScriptPackage.eINSTANCE.template)

		issue.addImportTemplateFix(acceptor, linkText)
		issue.addLocalTemplateFix(acceptor, linkText)

	}

	def void addLocalTemplateFix(Issue issue, IssueResolutionAcceptor acceptor, String linkText) {
		if (linkText != null) {

			acceptor.accept(issue, 'Create local template \'' + linkText + '\'',
				'Create local template \'' + linkText + '\'', null) [ element, context |
				if (element instanceof Character) {

					val model = EcoreUtil2.getContainerOfType(element, Characters)

					val template = CharacterScriptFactory.eINSTANCE.createTemplate
					template.name = linkText
					val character = element as Character
					character.properties.forEach [
						switch it {
							FullName: {
								template.defaults.add("full name")
							}
							Age: {
								template.defaults.add("age")
							}
							Description: {
								template.defaults.add("description")
							}
							Sex: {
								template.defaults.add("sex")
							}
							Type: {
								template.defaults.add("type")
							}
							CustomProperty: {

								val nodeForCARef = NodeModelUtils.findActualNodeFor(it)
								val nodeCandidates = nodeForCARef.asTreeIterable.filter(LeafNode).filter[
									!(it instanceof HiddenLeafNode) && !(it.grammarElement instanceof Keyword)]

								if (nodeCandidates.length <= 2) {

									val ca = CharacterScriptFactory.eINSTANCE.createCustomAttribute
									val caName = CharacterScriptFactory.eINSTANCE.createCustomAttributeName

									caName.name = nodeCandidates.get(0).text
									ca.caName = caName

									if (it.enumValue != null) {
										if (nodeCandidates.get(1) != null) {
											val ev = CharacterScriptFactory.eINSTANCE.createEnumValue
											ev.name = nodeCandidates.get(1).text
											ca.enumValues.add(ev)
										}
									} else if (it.stringValue != null) {
										ca.type = AttributeType.TEXT
									} else {
										ca.type = AttributeType.NUMBER
									}
									ca.required = '!'
									template.customs.add(ca)
								}
							}
						}
					]

					model.templates.add(template)
				}
			]
		}
	}
	
//	@Fix(MyDslValidator::INVALID_NAME)
//	def capitalizeName(Issue issue, IssueResolutionAcceptor acceptor) {
//		acceptor.accept(issue, 'Capitalize name', 'Capitalize the name.', 'upcase.png') [
//			context |
//			val xtextDocument = context.xtextDocument
//			val firstLetter = xtextDocument.get(issue.offset, 1)
//			xtextDocument.replace(issue.offset, 1, firstLetter.toUpperCase)
//		]
//	}
}
