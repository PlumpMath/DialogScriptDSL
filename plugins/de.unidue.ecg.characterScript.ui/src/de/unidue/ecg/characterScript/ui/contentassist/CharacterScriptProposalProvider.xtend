/*
 * generated by Xtext
 */
package de.unidue.ecg.characterScript.ui.contentassist

import de.unidue.ecg.characterScript.characterScript.Character
import de.unidue.ecg.characterScript.characterScript.CharacterScriptPackage
import de.unidue.ecg.characterScript.characterScript.CustomAttribute
import de.unidue.ecg.characterScript.characterScript.CustomProperty
import de.unidue.ecg.characterScript.characterScript.DefaultProperty
import de.unidue.ecg.characterScript.characterScript.Template
import de.unidue.ecg.characterScript.util.LanguageUtil
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.Assignment
import org.eclipse.xtext.CrossReference
import org.eclipse.xtext.Keyword
import org.eclipse.xtext.RuleCall
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor

/**
 * see http://www.eclipse.org/Xtext/documentation.html#contentAssist on how to customize content assistant
 */
class CharacterScriptProposalProvider extends AbstractCharacterScriptProposalProvider {

	override completeCustomProperty_EnumValue(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		val cp = model as CustomProperty
		val ca = cp.customAttributeRef.eContainer as CustomAttribute
		if (!ca?.enumValues.empty)
			super.completeCustomProperty_EnumValue(model, assignment, context, acceptor)
	}

	override completeCustomProperty_CustomAttributeRef(EObject model, Assignment assignment,
		ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		lookupCrossReference((assignment.terminal as CrossReference), context, acceptor) [ ieod |
			!(model as Character).properties.filter(CustomProperty).exists [ cp |
				ieod.EObjectOrProxy == cp.customAttributeRef
			]
		]
	}

	override complete_INT(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		if (model instanceof CustomProperty) {
			val cp = model as CustomProperty
			val ca = cp.customAttributeRef.eContainer as CustomAttribute
			if (!ca.enumValues.empty || !ca.type.getName().equals("NUMBER"))
				return
		}

		super.complete_INT(model, ruleCall, context, acceptor)
	}

	override complete_STRING(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		if (model instanceof CustomProperty) {
			val cp = model as CustomProperty
			val ca = cp.customAttributeRef.eContainer as CustomAttribute
			if (!ca.enumValues.empty || !ca.type.getName().equals("TEXT"))
				return
		}

		super.complete_STRING(model, ruleCall, context, acceptor)
	}

	override completeImport_ImportedNamespace(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		val scope = this.scopeProvider.getScope(context.rootModel, CharacterScriptPackage.Literals.CHARACTER__TEMPLATE)
		scope.allElements.filter[ieod|ieod.EObjectOrProxy instanceof Template].forEach [ element |
			acceptor.accept(createCompletionProposal(element.qualifiedName.toString, context))
		]

	//super.completeImport_ImportedNamespace(model, assignment, context, acceptor)
	}

	override completeKeyword(Keyword keyword, ContentAssistContext contentAssistContext,
		ICompletionProposalAcceptor acceptor) {
		val model = contentAssistContext.currentModel
		switch (model) {
			Character: {
				if(filter(keyword, model)) {
					return
				}
//				if (model.template != null && filter(keyword, model, model.template))
//					return
//				else if(model.template == null && filter(keyword, model))
//					return
			}
		}

		super.completeKeyword(keyword, contentAssistContext, acceptor)

	}

	def private filter(Keyword keyword, Character character) {
		if (character == null)
			return false

		val filterList = newArrayList
		
		// add already used defaults to filterList
		character.properties.filter(DefaultProperty).forEach [
			filterList.add(LanguageUtil.getKeywordValueFor(it.eClass))
		]

		if (filterList.contains(keyword.value)) {
			return true
		}
		return false
	}

//	def private filter(Keyword keyword, Character character, Template template) {
//		if (template == null)
//			return false
//
//		// first, add all available defaults to filter list
//		val filterList = newArrayList
////		LanguageUtil.defaultAttributes.forEach[k,v|
////			filterList.add(k)
////		]
////
////		// permit the ones that are provided by the template
////		template.defaults.forEach [
////			filterList.remove(it)
////		]
//		
//		// prohibit the ones already used
//		character.properties.filter(DefaultProperty).forEach [
//			filterList.add(LanguageUtil.getKeywordValueFor(it.eClass))
//		]
//
//		if (filterList.contains(keyword.value)) {
//			return true
//		}
//		return false
//	}

}
