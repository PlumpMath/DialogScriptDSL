/**
 * generated by Xtext
 */
package de.unidue.ecg.dialogScript.validation;

import com.google.common.base.Objects;
import de.unidue.ecg.dialogScript.dialogScript.AbstractChoiceDialog;
import de.unidue.ecg.dialogScript.dialogScript.ChoiceDialog;
import de.unidue.ecg.dialogScript.dialogScript.ConditionDefinition;
import de.unidue.ecg.dialogScript.dialogScript.ConditionList;
import de.unidue.ecg.dialogScript.dialogScript.Conditional;
import de.unidue.ecg.dialogScript.dialogScript.ConditionalBody;
import de.unidue.ecg.dialogScript.dialogScript.ConditionalChoiceDialog;
import de.unidue.ecg.dialogScript.dialogScript.DialogScriptPackage;
import de.unidue.ecg.dialogScript.dialogScript.Exit;
import de.unidue.ecg.dialogScript.dialogScript.Hub;
import de.unidue.ecg.dialogScript.dialogScript.Jump;
import de.unidue.ecg.dialogScript.dialogScript.Modifier;
import de.unidue.ecg.dialogScript.dialogScript.Otherwise;
import de.unidue.ecg.dialogScript.dialogScript.OtherwiseChoice;
import de.unidue.ecg.dialogScript.dialogScript.Scene;
import de.unidue.ecg.dialogScript.dialogScript.Script;
import de.unidue.ecg.dialogScript.dialogScript.SwitchDefinition;
import de.unidue.ecg.dialogScript.validation.AbstractDialogScriptValidator;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;

/**
 * Custom validation rules.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
@SuppressWarnings("all")
public class DialogScriptValidator extends AbstractDialogScriptValidator {
  public final static String EMPTY_SCENE = "emptyScene";
  
  public final static String COMMENT_IN_SCENE = "commentInScene";
  
  public final static String CONDITION_UNKNOWN = "conditionUnknown";
  
  public final static String UNREACHABLE_OTHERWISE_STATEMENT = "unreachableOtherwiseStatement";
  
  public final static String UNREFERENCED_HUB = "unreferencedHub";
  
  public final static String WILDCARD_IN_SCENE_NAME = "wildcardInSceneName";
  
  public final static String WILDCARD_IN_HUB_NAME = "wildcardInHubName";
  
  public final static String WILDCARD_IN_CHOICE_NAME = "wildcardInChoiceName";
  
  public final static String UPPER_CASE_SWTICH_DEFINITION = "upperCaseSwitchDefinition";
  
  public final static String LOWER_CASE_CONDITION_DEFINITION = "lowerCaseConditionDefinition";
  
  public final static String HUB_WITHOUT_CHOICE = "hubWithoutChoice";
  
  public final static String MISPLACED_EXIT_HUB = "misplacedExitHub";
  
  public final static String EMPTY_CHOICE = "emptyChoice";
  
  public final static String HUB_CANNOT_BE_LEFT = "hubCannotBeLeft";
  
  public final static String DUPLICATED_MODIFIER = "duplicatedModifier";
  
  public final static String WRONG_CONDTIONAL_USAGE = "wrongConditionalUsage";
  
  public final static String UNRESOLVED_CHARACTER = "unresolvedCharacter";
  
  @Check
  public void checkHubCanBeLeft(final Hub hub) {
    final TreeIterator<EObject> allContents = hub.eAllContents();
    boolean _hasNext = allContents.hasNext();
    boolean _while = _hasNext;
    while (_while) {
      EObject _next = allContents.next();
      if ((_next instanceof Jump)) {
        return;
      }
      boolean _hasNext_1 = allContents.hasNext();
      _while = _hasNext_1;
    }
    this.warning("Hub cannot be left by the player. Add an exit- or enter hub-statement to avoid infinite loops.", hub, 
      DialogScriptPackage.Literals.HUB__NAME, DialogScriptValidator.HUB_CANNOT_BE_LEFT);
  }
  
  @Check
  public void checkForEmptyChoice(final ChoiceDialog choice) {
    ConditionalBody _body = choice.getBody();
    boolean _equals = Objects.equal(_body, null);
    if (_equals) {
      this.warning("Empty choices should be removed.", choice, DialogScriptPackage.Literals.CHOICE_DIALOG__NAME, 
        DialogScriptValidator.EMPTY_CHOICE);
    }
  }
  
  @Check
  public void checkForLowerCaseSwitches(final SwitchDefinition switchDefinition) {
    String _name = switchDefinition.getName();
    char _charAt = _name.charAt(0);
    boolean _isUpperCase = Character.isUpperCase(_charAt);
    if (_isUpperCase) {
      this.warning("It is recommended to start switches with a lower case letter", switchDefinition, 
        DialogScriptPackage.Literals.SWITCH_DEFINITION__NAME, DialogScriptValidator.UPPER_CASE_SWTICH_DEFINITION);
    }
  }
  
  @Check
  public void checkForUpperCaseConditions(final ConditionDefinition conditionDefinition) {
    String _name = conditionDefinition.getName();
    char _charAt = _name.charAt(0);
    boolean _isLowerCase = Character.isLowerCase(_charAt);
    if (_isLowerCase) {
      this.warning("It is recommended to start conditions with a upper case letter", conditionDefinition, 
        DialogScriptPackage.Literals.CONDITION_DEFINITION__NAME, DialogScriptValidator.LOWER_CASE_CONDITION_DEFINITION);
    }
  }
  
  @Check
  public void checkForUnreachableOtherwiseStatements(final Conditional conditional) {
    EList<Otherwise> _otherwiseList = conditional.getOtherwiseList();
    boolean _notEquals = (!Objects.equal(_otherwiseList, null));
    if (_notEquals) {
      EList<Otherwise> _otherwiseList_1 = conditional.getOtherwiseList();
      final Iterator<Otherwise> iterator = _otherwiseList_1.iterator();
      boolean _hasNext = iterator.hasNext();
      boolean _while = _hasNext;
      while (_while) {
        {
          final Otherwise next = iterator.next();
          boolean _and = false;
          ConditionList _conditionList = next.getConditionList();
          boolean _equals = Objects.equal(_conditionList, null);
          if (!_equals) {
            _and = false;
          } else {
            boolean _hasNext_1 = iterator.hasNext();
            _and = (_equals && _hasNext_1);
          }
          if (_and) {
            final Otherwise issueElement = iterator.next();
            EList<Otherwise> _otherwiseList_2 = conditional.getOtherwiseList();
            int _indexOf = _otherwiseList_2.indexOf(issueElement);
            this.warning("Unreachable area: Conditional dialog after an unconditional dialog cannot be reached", issueElement, DialogScriptPackage.Literals.OTHERWISE__BODY, _indexOf, DialogScriptValidator.UNREACHABLE_OTHERWISE_STATEMENT);
            return;
          }
        }
        boolean _hasNext_1 = iterator.hasNext();
        _while = _hasNext_1;
      }
    }
  }
  
  @Check
  public void checkForHubsWithoutChoice(final Hub hub) {
    EList<AbstractChoiceDialog> _choiceDialogs = hub.getChoiceDialogs();
    for (final AbstractChoiceDialog c : _choiceDialogs) {
      boolean _or = false;
      if ((c instanceof ConditionalChoiceDialog)) {
        _or = true;
      } else {
        _or = ((c instanceof ConditionalChoiceDialog) || (c instanceof ChoiceDialog));
      }
      if (_or) {
        return;
      }
    }
    this.error("A hub has to contain at least one choice!", hub, DialogScriptPackage.Literals.HUB__NAME, 
      DialogScriptValidator.HUB_WITHOUT_CHOICE);
  }
  
  @Check
  public void checkForMisplacedExitHubs(final Exit exit) {
    boolean _isExitHub = exit.isExitHub();
    if (_isExitHub) {
      boolean _isInHub = this.isInHub(exit);
      boolean _not = (!_isInHub);
      if (_not) {
        this.error("You are not in a hub, so this statement does not make sense!", exit, 
          DialogScriptPackage.Literals.EXIT__EXIT_HUB, DialogScriptValidator.MISPLACED_EXIT_HUB);
      }
    }
  }
  
  public boolean isInHub(final EObject element) {
    boolean _xifexpression = false;
    if ((element instanceof Hub)) {
      _xifexpression = true;
    } else {
      boolean _xifexpression_1 = false;
      EObject _eContainer = element.eContainer();
      boolean _equals = Objects.equal(_eContainer, null);
      if (_equals) {
        _xifexpression_1 = false;
      } else {
        EObject _eContainer_1 = element.eContainer();
        boolean _isInHub = this.isInHub(_eContainer_1);
        _xifexpression_1 = _isInHub;
      }
      _xifexpression = _xifexpression_1;
    }
    return _xifexpression;
  }
  
  @Check
  public void checkIfHiddenHubIsCalled(final Hub hub) {
    boolean _isIsHidden = hub.isIsHidden();
    if (_isIsHidden) {
      final HashSet<Hub> set = CollectionLiterals.<Hub>newHashSet(hub);
      final ArrayList<EObject> result = CollectionLiterals.<EObject>newArrayList();
      Script _containerOfType = EcoreUtil2.<Script>getContainerOfType(hub, Script.class);
      final EcoreUtil2.ElementReferenceAcceptor _function = new EcoreUtil2.ElementReferenceAcceptor() {
        public void accept(final EObject referrer, final EObject referenced, final EReference reference, final int index) {
          result.add(referrer);
        }
      };
      EcoreUtil2.findCrossReferences(_containerOfType, set, _function);
      boolean _isEmpty = result.isEmpty();
      if (_isEmpty) {
        String _name = hub.getName();
        String _plus = ("Hidden hub " + _name);
        String _plus_1 = (_plus + 
          " is never entered explicitly. As a consequence, its content won\'t be reachable during play. Delete the \'hidden\' modifier or enter the hub from another point in your scene.");
        this.warning(_plus_1, hub, DialogScriptPackage.Literals.HUB__NAME, DialogScriptValidator.UNREFERENCED_HUB);
      }
    }
  }
  
  @Check
  public void checkForWildcardsInNonDialogLines(final Scene ele) {
    String _name = ele.getName();
    int _indexOf = _name.indexOf("{");
    boolean _greaterThan = (_indexOf > (-1));
    if (_greaterThan) {
      this.warning("Wildcards can not be processed in a scene name!", ele, DialogScriptPackage.Literals.SCENE__NAME, 
        DialogScriptValidator.WILDCARD_IN_SCENE_NAME);
    }
  }
  
  @Check
  public void checkForWildcardsInNonDialogLines(final Hub ele) {
    String _name = ele.getName();
    int _indexOf = _name.indexOf("{");
    boolean _greaterThan = (_indexOf > (-1));
    if (_greaterThan) {
      this.warning("Wildcards can not be processed in a hub name!", ele, DialogScriptPackage.Literals.HUB__NAME, 
        DialogScriptValidator.WILDCARD_IN_HUB_NAME);
    }
  }
  
  @Check
  public void checkForWildcardsInNonDialogLines(final ChoiceDialog ele) {
    String _name = ele.getName();
    int _indexOf = _name.indexOf("{");
    boolean _greaterThan = (_indexOf > (-1));
    if (_greaterThan) {
      this.warning("Wildcards can not be processed in a choice name!", ele, 
        DialogScriptPackage.Literals.CHOICE_DIALOG__NAME, DialogScriptValidator.WILDCARD_IN_CHOICE_NAME);
    }
  }
  
  @Check
  public void checkForModifierDuplicates(final Otherwise ele) {
    EList<Modifier> _modifiers = ele.getModifiers();
    this.checkForModifierDuplicates(_modifiers, ele, DialogScriptPackage.Literals.OTHERWISE__MODIFIERS);
  }
  
  @Check
  public void checkForModifierDuplicates(final Conditional ele) {
    EList<Modifier> _modifiers = ele.getModifiers();
    this.checkForModifierDuplicates(_modifiers, ele, DialogScriptPackage.Literals.ABSTRACT_CHOICE_DIALOG__MODIFIERS);
  }
  
  @Check
  public void checkForModifierDuplicates(final ChoiceDialog ele) {
    EList<Modifier> _modifiers = ele.getModifiers();
    this.checkForModifierDuplicates(_modifiers, ele, DialogScriptPackage.Literals.ABSTRACT_CHOICE_DIALOG__MODIFIERS);
  }
  
  @Check
  public void checkForModifierDuplicates(final OtherwiseChoice ele) {
    EList<Modifier> _modifiers = ele.getModifiers();
    this.checkForModifierDuplicates(_modifiers, ele, DialogScriptPackage.Literals.OTHERWISE_CHOICE__MODIFIERS);
  }
  
  @Check
  public void checkForModifierDuplicates(final ConditionalChoiceDialog ele) {
    EList<Modifier> _modifiers = ele.getModifiers();
    this.checkForModifierDuplicates(_modifiers, ele, DialogScriptPackage.Literals.ABSTRACT_CHOICE_DIALOG__MODIFIERS);
  }
  
  public void checkForModifierDuplicates(final List<Modifier> modifiers, final EObject obj, final EStructuralFeature feature) {
    final Procedure1<Modifier> _function = new Procedure1<Modifier>() {
      public void apply(final Modifier it) {
        final int first = modifiers.indexOf(it);
        final int last = modifiers.lastIndexOf(it);
        if ((first != last)) {
          DialogScriptValidator.this.error("You cannot use a modifier several times", obj, feature, last, DialogScriptValidator.DUPLICATED_MODIFIER);
        }
      }
    };
    IterableExtensions.<Modifier>forEach(modifiers, _function);
  }
  
  @Check
  public void checkForCorrectConditionalsInHub(final Conditional ele) {
    EObject _eContainer = ele.eContainer();
    if ((_eContainer instanceof Hub)) {
      EObject _eContainer_1 = ele.eContainer();
      final Hub hub = ((Hub) _eContainer_1);
      boolean _and = false;
      EList<Modifier> _modifiers = ele.getModifiers();
      boolean _contains = _modifiers.contains(Modifier.SINGLE);
      boolean _not = (!_contains);
      if (!_not) {
        _and = false;
      } else {
        boolean _or = false;
        ConditionalBody _body = ele.getBody();
        boolean _equals = Objects.equal(_body, null);
        if (_equals) {
          _or = true;
        } else {
          boolean _and_1 = false;
          ConditionalBody _body_1 = ele.getBody();
          boolean _notEquals = (!Objects.equal(_body_1, null));
          if (!_notEquals) {
            _and_1 = false;
          } else {
            ConditionalBody _body_2 = ele.getBody();
            Jump _jump = _body_2.getJump();
            boolean _equals_1 = Objects.equal(_jump, null);
            _and_1 = (_notEquals && _equals_1);
          }
          _or = (_equals || _and_1);
        }
        _and = (_not && _or);
      }
      if (_and) {
        EList<AbstractChoiceDialog> _choiceDialogs = hub.getChoiceDialogs();
        int _indexOf = _choiceDialogs.indexOf(ele);
        EList<AbstractChoiceDialog> _choiceDialogs_1 = hub.getChoiceDialogs();
        int _indexOf_1 = _choiceDialogs_1.indexOf(ele);
        String _string = Integer.valueOf(_indexOf_1).toString();
        this.error(
          "Inside a hub, conditionals has to be either declared as \'single\' or has to exit the hub explicitly using a \'exit\' or \'enter\' statement", hub, DialogScriptPackage.Literals.HUB__CHOICE_DIALOGS, _indexOf, 
          DialogScriptValidator.WRONG_CONDTIONAL_USAGE, _string);
      }
    }
  }
}
