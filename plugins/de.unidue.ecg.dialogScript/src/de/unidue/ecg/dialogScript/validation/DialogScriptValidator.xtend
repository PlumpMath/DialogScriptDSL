/*
 * generated by Xtext
 */
package de.unidue.ecg.dialogScript.validation

import de.unidue.ecg.dialogScript.dialogScript.ChoiceDialog
import de.unidue.ecg.dialogScript.dialogScript.ConditionDefinition
import de.unidue.ecg.dialogScript.dialogScript.Conditional
import de.unidue.ecg.dialogScript.dialogScript.ConditionalChoiceDialog
import de.unidue.ecg.dialogScript.dialogScript.DialogScriptPackage
import de.unidue.ecg.dialogScript.dialogScript.Exit
import de.unidue.ecg.dialogScript.dialogScript.Hub
import de.unidue.ecg.dialogScript.dialogScript.Jump
import de.unidue.ecg.dialogScript.dialogScript.Modifier
import de.unidue.ecg.dialogScript.dialogScript.Otherwise
import de.unidue.ecg.dialogScript.dialogScript.OtherwiseChoice
import de.unidue.ecg.dialogScript.dialogScript.Scene
import de.unidue.ecg.dialogScript.dialogScript.Script
import de.unidue.ecg.dialogScript.dialogScript.SwitchDefinition
import java.util.List
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.validation.Check

//import org.eclipse.xtext.validation.Check
/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class DialogScriptValidator extends AbstractDialogScriptValidator {

	public static val EMPTY_SCENE = 'emptyScene'
	public static val COMMENT_IN_SCENE = 'commentInScene'
	public static val CONDITION_UNKNOWN = 'conditionUnknown'
	public static val UNREACHABLE_OTHERWISE_STATEMENT = 'unreachableOtherwiseStatement'
	public static val UNREFERENCED_HUB = 'unreferencedHub'
	public static val WILDCARD_IN_SCENE_NAME = 'wildcardInSceneName'
	public static val WILDCARD_IN_HUB_NAME = 'wildcardInHubName'
	public static val WILDCARD_IN_CHOICE_NAME = 'wildcardInChoiceName'
	public static val UPPER_CASE_SWTICH_DEFINITION = 'upperCaseSwitchDefinition'
	public static val LOWER_CASE_CONDITION_DEFINITION = 'lowerCaseConditionDefinition'
	public static val HUB_WITHOUT_CHOICE = 'hubWithoutChoice'
	public static val MISPLACED_EXIT_HUB = 'misplacedExitHub'
	public static val EMPTY_CHOICE = 'emptyChoice'
	public static val HUB_CANNOT_BE_LEFT = 'hubCannotBeLeft'
	public static val DUPLICATED_MODIFIER = 'duplicatedModifier'
	public static val WRONG_CONDTIONAL_USAGE = 'wrongConditionalUsage'

	//	@Check
	//	def checkSceneDescriptionIsNotEmpty(Scene scene) {
	//		if (scene.sceneDescription.trim.equals('-'))
	//			warning('Scene description should not be empty', DialogScriptPackage.Literals.SCENE__SCENE_DESCRIPTION,
	//				EMPTY_SCENE)
	//	}
	//	@Check
	//	def checkSceneDescriptionIsNotTemplate(Scene scene) {
	//		if (scene.sceneDescription.contains('sceneDescription_SingleLineOnly'))
	//			info('Try to find a meaningful description for your scene',
	//				DialogScriptPackage.Literals.SCENE__SCENE_DESCRIPTION, EMPTY_SCENE)
	//	}
	//	@Check
	//	def checkSceneContainsComment(Scene scene) {
	//		if ((scene.sceneDescription.indexOf('[') < scene.sceneDescription.indexOf(']') &&
	//			scene.sceneDescription.indexOf('[') >= 0) || (scene.sceneDescription.indexOf('//') >= 0)) {
	//			warning(
	//				'The comment in your scene description is not recognized as a comment (note the missing formatting!). Use a new line to provide a comment for the scene description.',
	//				DialogScriptPackage.Literals.SCENE__SCENE_DESCRIPTION, COMMENT_IN_SCENE)
	//		}
	//	}
	
//	@Check
//	def checkForUnreachableOtherwiseStatements(Dialog dialog) {
//		for (Conditional conditional : dialog.recursives.filter(Conditional)) {
//			if (conditional.otherwiseList != null) {
//				val unreachable = conditional.otherwiseList.findFirst[it.conditionList == null]
//				if (unreachable != null) {
//					warning(
//						'Unreachable area: Unconditional dialog on the most outer level of a conditional statement is ignored. Use the \'Other times\' statement instead!',
//						unreachable, DialogScriptPackage.Literals.OTHERWISE__BODY, UNREACHABLE_OTHERWISE_STATEMENT)
//				}
//			}
//		}
//	}
	
	@Check
	def checkHubCanBeLeft(Hub hub) {
		val allContents = hub.eAllContents
		while(allContents.hasNext) {
			if(allContents.next instanceof Jump)
				return
		}
		
		warning('Hub cannot be left by the player. Add an exit- or enter hub-statement to avoid infinite loops.', hub, DialogScriptPackage.Literals.HUB__NAME, HUB_CANNOT_BE_LEFT)
	}
	
	@Check
	def checkForEmptyChoice(ChoiceDialog choice) {
		if(choice.body == null)
			warning('Empty choices should be removed.',
						choice, DialogScriptPackage.Literals.CHOICE_DIALOG__NAME, EMPTY_CHOICE)
	}

	@Check
	def checkForLowerCaseSwitches(SwitchDefinition switchDefinition) {
		if (Character.isUpperCase(switchDefinition.name.charAt(0))) {
			warning('It is recommended to start switches with a lower case letter', switchDefinition,
				DialogScriptPackage.Literals.SWITCH_DEFINITION__NAME, UPPER_CASE_SWTICH_DEFINITION)
		}
	}

	@Check
	def checkForUpperCaseConditions(ConditionDefinition conditionDefinition) {
		if (Character.isLowerCase(conditionDefinition.name.charAt(0))) {
			warning('It is recommended to start conditions with a upper case letter', conditionDefinition,
				DialogScriptPackage.Literals.CONDITION_DEFINITION__NAME, LOWER_CASE_CONDITION_DEFINITION)
		}
	}

	@Check
	def checkForUnreachableOtherwiseStatements(Conditional conditional) {
		if (conditional.otherwiseList != null) {
			val iterator = conditional.otherwiseList.iterator
			while (iterator.hasNext) {
				val next = iterator.next
				if (next.conditionList == null && iterator.hasNext) {
					val issueElement = iterator.next
					warning('Unreachable area: Conditional dialog after an unconditional dialog cannot be reached',
						issueElement, DialogScriptPackage.Literals.OTHERWISE__BODY,
						conditional.otherwiseList.indexOf(issueElement), UNREACHABLE_OTHERWISE_STATEMENT)
					return
				}
			}
		}
	}

	@Check
	def checkForHubsWithoutChoice(Hub hub) {
		for (c : hub.choiceDialogs) {
			if (c instanceof ConditionalChoiceDialog || c instanceof ChoiceDialog)
				return
		}
		error('A hub has to contain at least one choice!', hub, DialogScriptPackage.Literals.HUB__NAME,
			HUB_WITHOUT_CHOICE)
	}
	
	@Check
	def checkForMisplacedExitHubs(Exit exit) {
		if(exit.exitHub) {
			if(!isInHub(exit)) {
				error('You are not in a hub, so this statement does not make sense!', exit, DialogScriptPackage.Literals.EXIT__EXIT_HUB, MISPLACED_EXIT_HUB)
			}
		}
	}
	
	def boolean isInHub(EObject element) {
		if(element instanceof Hub)
			true
		else if (element.eContainer == null)
			false
		else
			isInHub(element.eContainer)
	}

	@Check
	def checkIfHiddenHubIsCalled(Hub hub) {
		if (hub.isHidden) {
			val set = newHashSet(hub)
			val result = newArrayList()
			EcoreUtil2.findCrossReferences(EcoreUtil2.getContainerOfType(hub, Script), set) [ EObject referrer, EObject referenced, EReference reference, int index |
				result.add(referrer)
			]

			if (result.empty) {
				warning(
					'Hidden hub ' + hub.name +
						' is never entered explicitly. As a consequence, its content won\'t be reachable during play. Delete the \'hidden\' modifier or enter the hub from another point in your scene.',
					hub, DialogScriptPackage.Literals.HUB__NAME, UNREFERENCED_HUB)
			}
		}
	}

	@Check
	def checkForWildcardsInNonDialogLines(Scene ele) {
		if (ele.name.indexOf('{') > -1) {
			warning('Wildcards can not be processed in a scene name!', ele, DialogScriptPackage.Literals.SCENE__NAME,
				WILDCARD_IN_SCENE_NAME)
		}
	}

	@Check
	def checkForWildcardsInNonDialogLines(Hub ele) {
		if (ele.name.indexOf('{') > -1) {
			warning('Wildcards can not be processed in a hub name!', ele, DialogScriptPackage.Literals.HUB__NAME,
				WILDCARD_IN_HUB_NAME)
		}
	}

	@Check
	def checkForWildcardsInNonDialogLines(ChoiceDialog ele) {
		if (ele.name.indexOf('{') > -1) {
			warning('Wildcards can not be processed in a choice name!', ele,
				DialogScriptPackage.Literals.CHOICE_DIALOG__NAME, WILDCARD_IN_CHOICE_NAME)
		}
	}
	
	@Check
	def checkForModifierDuplicates(Otherwise ele) {
		checkForModifierDuplicates(ele.modifiers, ele, DialogScriptPackage.Literals.OTHERWISE__MODIFIERS)
	}
	
	@Check
	def checkForModifierDuplicates(Conditional ele) {
		checkForModifierDuplicates(ele.modifiers, ele, DialogScriptPackage.Literals.ABSTRACT_CHOICE_DIALOG__MODIFIERS)
	}
	
	@Check
	def checkForModifierDuplicates(ChoiceDialog ele) {
		checkForModifierDuplicates(ele.modifiers, ele, DialogScriptPackage.Literals.ABSTRACT_CHOICE_DIALOG__MODIFIERS)
	}
	
	@Check
	def checkForModifierDuplicates(OtherwiseChoice ele) {
		checkForModifierDuplicates(ele.modifiers, ele, DialogScriptPackage.Literals.OTHERWISE_CHOICE__MODIFIERS)
	}
	
	@Check
	def checkForModifierDuplicates(ConditionalChoiceDialog ele) {
		checkForModifierDuplicates(ele.modifiers, ele, DialogScriptPackage.Literals.ABSTRACT_CHOICE_DIALOG__MODIFIERS)
	}
	
	def checkForModifierDuplicates(List<Modifier> modifiers, EObject obj, EStructuralFeature feature) {
		modifiers.forEach[ 
			val first = modifiers.indexOf(it)
			val last = modifiers.lastIndexOf(it)
			if(first != last) {
				error('You cannot use a modifier several times', obj, feature, last, DUPLICATED_MODIFIER)
			}			
		]
	}
	
	@Check
	def checkForCorrectConditionalsInHub(Conditional ele) {
		if(ele.eContainer instanceof Hub) {
			val hub = ele.eContainer as Hub
			if(!ele.modifiers.contains(Modifier.SINGLE) && (ele.body == null || ele.body != null && ele.body.jump == null)) {
				error('Inside a hub, conditionals has to be either declared as \'single\' or has to exit the hub explicitly using a \'exit\' or \'enter\' statement',
					hub, DialogScriptPackage.Literals.HUB__CHOICE_DIALOGS, hub.choiceDialogs.indexOf(ele), WRONG_CONDTIONAL_USAGE, hub.choiceDialogs.indexOf(ele).toString)		
			}
		}
	}

}
