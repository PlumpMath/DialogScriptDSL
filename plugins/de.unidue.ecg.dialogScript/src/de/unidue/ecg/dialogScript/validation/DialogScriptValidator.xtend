/*
 * generated by Xtext
 */
package de.unidue.ecg.dialogScript.validation

import de.unidue.ecg.dialogScript.dialogScript.ChoiceDialog
import de.unidue.ecg.dialogScript.dialogScript.ConditionDefinition
import de.unidue.ecg.dialogScript.dialogScript.Conditional
import de.unidue.ecg.dialogScript.dialogScript.ConditionalChoiceDialog
import de.unidue.ecg.dialogScript.dialogScript.DialogScriptPackage
import de.unidue.ecg.dialogScript.dialogScript.Exit
import de.unidue.ecg.dialogScript.dialogScript.Hub
import de.unidue.ecg.dialogScript.dialogScript.Jump
import de.unidue.ecg.dialogScript.dialogScript.Modifier
import de.unidue.ecg.dialogScript.dialogScript.Otherwise
import de.unidue.ecg.dialogScript.dialogScript.OtherwiseChoice
import de.unidue.ecg.dialogScript.dialogScript.Scene
import de.unidue.ecg.dialogScript.dialogScript.Script
import de.unidue.ecg.dialogScript.dialogScript.SwitchDefinition
import java.util.List
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.validation.Check
import de.unidue.ecg.dialogScript.dialogScript.Defaults
import de.unidue.ecg.dialogScript.dialogScript.ConditionalBody
import de.unidue.ecg.dialogScript.dialogScript.FirstTime

//import org.eclipse.xtext.validation.Check
/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class DialogScriptValidator extends AbstractDialogScriptValidator {

	public static val EMPTY_SCENE = 'emptyScene'
	public static val COMMENT_IN_SCENE = 'commentInScene'
	public static val CONDITION_UNKNOWN = 'conditionUnknown'
	public static val UNREACHABLE_OTHERWISE_STATEMENT = 'unreachableOtherwiseStatement'
	public static val UNREFERENCED_HUB = 'unreferencedHub'
	public static val WILDCARD_IN_SCENE_NAME = 'wildcardInSceneName'
	public static val WILDCARD_IN_HUB_NAME = 'wildcardInHubName'
	public static val WILDCARD_IN_CHOICE_NAME = 'wildcardInChoiceName'
	public static val UPPER_CASE_SWTICH_DEFINITION = 'upperCaseSwitchDefinition'
	public static val LOWER_CASE_CONDITION_DEFINITION = 'lowerCaseConditionDefinition'
	public static val HUB_WITHOUT_CHOICE = 'hubWithoutChoice'
	public static val MISPLACED_EXIT_HUB = 'misplacedExitHub'
	public static val EMPTY_CHOICE = 'emptyChoice'
	public static val HUB_CANNOT_BE_LEFT = 'hubCannotBeLeft'
	public static val DUPLICATED_MODIFIER = 'duplicatedModifier'
	public static val WRONG_CONDTIONAL_USAGE = 'wrongConditionalUsage'
	public static val UNRESOLVED_CHARACTER = 'unresolvedCharacter'
	public static val EMPTY_BODY = 'emptyBody'

	@Check
	def checkHubCanBeLeft(Hub hub) {
		val allContents = hub.eAllContents
		while (allContents.hasNext) {
			if (allContents.next instanceof Jump)
				return
		}

		warning(
			'Its a trap! Hub cannot be left by the player. Add an "exit- " or "enter"-statement to avoid infinite loops.',
			hub, DialogScriptPackage.Literals.HUB__NAME, HUB_CANNOT_BE_LEFT)
	}

	@Check
	def checkForEmptyChoice(ChoiceDialog choice) {
		if (choice.body == null)
			warning('Empty choices should be removed.', choice, DialogScriptPackage.Literals.CHOICE_DIALOG__NAME,
				EMPTY_CHOICE)
	}

	@Check
	def checkForLowerCaseSwitches(SwitchDefinition switchDefinition) {
		if (Character.isUpperCase(switchDefinition.name.charAt(0))) {
			warning('It is recommended to start switches with a lower case letter', switchDefinition,
				DialogScriptPackage.Literals.SWITCH_DEFINITION__NAME, UPPER_CASE_SWTICH_DEFINITION)
		}
	}

	@Check
	def checkForUpperCaseConditions(ConditionDefinition conditionDefinition) {
		if (Character.isLowerCase(conditionDefinition.name.charAt(0))) {
			warning('It is recommended to start conditions with a upper case letter', conditionDefinition,
				DialogScriptPackage.Literals.CONDITION_DEFINITION__NAME, LOWER_CASE_CONDITION_DEFINITION)
		}
	}

	@Check
	def checkForUnreachableOtherwiseStatements(Conditional conditional) {
		if (conditional.otherwiseList != null) {
			val iterator = conditional.otherwiseList.iterator
			while (iterator.hasNext) {
				val next = iterator.next
				if (next.conditionList == null && iterator.hasNext) {
					val issueElement = iterator.next
					warning('Unreachable area: Conditional dialog after an unconditional dialog cannot be reached',
						issueElement, DialogScriptPackage.Literals.OTHERWISE__BODY,
						conditional.otherwiseList.indexOf(issueElement), UNREACHABLE_OTHERWISE_STATEMENT)
					return
				}
			}
		}
	}

	@Check
	def checkForHubsWithoutChoice(Hub hub) {
		val choices = hub.hubFragments.filter(ChoiceDialog)
		if (choices.empty) {
			val conditionalChoices = hub.hubFragments.filter(ConditionalChoiceDialog)
			if(conditionalChoices.empty){			
				error('A hub has to contain at least one choice!', hub, DialogScriptPackage.Literals.HUB__NAME,
					HUB_WITHOUT_CHOICE)
			} 
		}
	}

	@Check
	def checkForMisplacedExitHubs(Exit exit) {
		if (exit.exitHub) {
			if (!isInHub(exit)) {
				error('You are not in a hub, so this statement does not make sense!', exit,
					DialogScriptPackage.Literals.EXIT__EXIT_HUB, MISPLACED_EXIT_HUB)
			}
		}
	}

	def boolean isInHub(EObject element) {
		if (element instanceof Hub)
			true
		else if (element.eContainer == null)
			false
		else
			isInHub(element.eContainer)
	}

	@Check
	def checkIfHiddenHubIsCalled(Hub hub) {
		if (hub.isHidden) {
			val set = newHashSet(hub)
			val result = newArrayList()
			EcoreUtil2.findCrossReferences(EcoreUtil2.getContainerOfType(hub, Script), set) [ EObject referrer, EObject referenced, EReference reference, int index |
				result.add(referrer)
			]

			if (result.empty) {
				warning(
					'Hidden hub ' + hub.name +
						' is never entered explicitly. As a consequence, its content won\'t be reachable during play. Delete the \'hidden\' modifier or enter the hub from another point in your scene.',
					hub, DialogScriptPackage.Literals.HUB__NAME, UNREFERENCED_HUB)
			}
		}
	}

	@Check
	def checkForWildcardsInNonDialogLines(Scene ele) {
		if (ele.name.indexOf('{') > -1) {
			warning('Wildcards can not be processed in a scene name!', ele, DialogScriptPackage.Literals.SCENE__NAME,
				WILDCARD_IN_SCENE_NAME)
		}
	}

	@Check
	def checkForWildcardsInNonDialogLines(Hub ele) {
		if (ele.name.indexOf('{') > -1) {
			warning('Wildcards can not be processed in a hub name!', ele, DialogScriptPackage.Literals.HUB__NAME,
				WILDCARD_IN_HUB_NAME)
		}
	}

	@Check
	def checkForWildcardsInNonDialogLines(ChoiceDialog ele) {
		if (ele.name.indexOf('{') > -1) {
			warning('Wildcards can not be processed in a choice name!', ele,
				DialogScriptPackage.Literals.CHOICE_DIALOG__NAME, WILDCARD_IN_CHOICE_NAME)
		}
	}

	@Check
	def checkForModifierDuplicates(Otherwise ele) {
		checkForModifierDuplicates(ele.modifiers, ele, DialogScriptPackage.Literals.OTHERWISE__MODIFIERS)
	}

	@Check
	def checkForModifierDuplicates(Conditional ele) {
		checkForModifierDuplicates(ele.modifiers, ele, DialogScriptPackage.Literals.CONDITIONAL__MODIFIERS)
	}

	@Check
	def checkForModifierDuplicates(ChoiceDialog ele) {
		checkForModifierDuplicates(ele.modifiers, ele, DialogScriptPackage.Literals.CHOICE_DIALOG__MODIFIERS)
	}

	@Check
	def checkForModifierDuplicates(OtherwiseChoice ele) {
		checkForModifierDuplicates(ele.modifiers, ele, DialogScriptPackage.Literals.OTHERWISE_CHOICE__MODIFIERS)
	}

	@Check
	def checkForModifierDuplicates(ConditionalChoiceDialog ele) {
		checkForModifierDuplicates(ele.modifiers, ele, DialogScriptPackage.Literals.CONDITIONAL_CHOICE_DIALOG__MODIFIERS)
	}

	def checkForModifierDuplicates(List<Modifier> modifiers, EObject obj, EStructuralFeature feature) {
		modifiers.forEach [
			val first = modifiers.indexOf(it)
			val last = modifiers.lastIndexOf(it)
			if (first != last) {
				error('You cannot use a modifier several times', obj, feature, last, DUPLICATED_MODIFIER)
			}
		]
	}

	/** WHY!?
	@Check
	def checkForCorrectConditionalsInHub(Conditional ele) {
		if (ele.eContainer instanceof Hub) {
			val hub = ele.eContainer as Hub
			if (!ele.modifiers.contains(Modifier.SINGLE) &&
				(ele.body == null || ele.body != null && ele.body.jump == null)) {
				error(
					'Inside a hub, conditionals have to be either declared as \'single\' or has to exit the hub explicitly using a \'exit\' or \'enter\' statement',
					hub, DialogScriptPackage.Literals.HUB__CHOICE_DIALOGS, hub.choiceDialogs.indexOf(ele),
					WRONG_CONDTIONAL_USAGE, hub.choiceDialogs.indexOf(ele).toString)
			}
		}
	} */
	@Check
	def checkForEmptyElseBody(Otherwise ele) {
		if (ele.conditionList == null || ele.conditionList.conditions.empty) {
			val conditional = ele.eContainer as Conditional
			val body = ele.body
			if (body.empty) {
				warning('Empty else-path detected. Will be ignored!', conditional,
					DialogScriptPackage.Literals.CONDITIONAL__OTHERWISE_LIST, conditional.otherwiseList.indexOf(ele),
					EMPTY_BODY, conditional.otherwiseList.indexOf(ele).toString)
			}
		}
	}

	@Check
	def checkForEmptyDefaultsBody(Defaults ele) {
		val body = ele.body
		if (body.empty) {
			warning('Empty body detected. Will be ignored!', ele.eContainer,
				DialogScriptPackage.Literals.DIALOG__DEFAULTS, EMPTY_BODY)
		}
	}

	@Check
	def checkForEmptyDefaultsBody(FirstTime ele) {
		val body = ele.body
		if (body.empty) {
			warning('Empty body detected. Will be ignored!', ele.eContainer,
				DialogScriptPackage.Literals.DIALOG__FIRST_TIME, EMPTY_BODY)
		}
	}

	private def isEmpty(ConditionalBody body) {
		if (body == null ||
			body.statements.empty && body.switchOn == null && body.switchOff == null && body.jump == null)
			return true
		return false
	}

//	@Check
//	def checkImports(DialogLine d) {
//
//		val charaName = d.character.name
//		val root = EcoreUtil2.getContainerOfType(d, Script)
//		var isIssue = false
//		val characters = root.charactersDefinition?.characters
//
//		if (characters == null) {
//			isIssue = true
//		} else {
//
//			val matchedImport = characters.findFirst[it.name.equals(charaName)]
//
//			if (matchedImport == null) {
//				isIssue = true
//			}
//		}
//
//		if (isIssue)
//			error('Missing character definition for ' + charaName,
//				DialogScriptPackage.Literals.DIALOG_LINE__CHARACTER, UNRESOLVED_CHARACTER, charaName)
//	}
}
